{"name":"Cavalieri","tagline":"A C++ event  stream processing tool to monitor and alert","body":"Cavalieri [![Build Status](https://drone.io/github.com/juruen/cavalieri/status.png)](https://drone.io/github.com/juruen/cavalieri/latest)\r\n=========\r\n\r\n\r\nIntroduction\r\n------------\r\n\r\n*Cavalieri* is a C++ event stream processing tool inspired by the\r\nawesome [riemann.io](http://riemann.io) project.\r\n\r\nIt implements the original [riemann.io](http://riemann.io) protocol. That means\r\nyou can leverage the existing *riemann* clients and tools. It also tries to\r\nmimic its stream API where possible.\r\n\r\nCavalieri's current version *0.0.6* is considered to be  in **alpha** state.\r\nWe expect to release a beta version in the following weeks.\r\n\r\nCurrent benchmarks show that it can process more than one million events per\r\nsecond with simple streams.\r\n\r\nInstall\r\n-------\r\n\r\n#### Ubuntu packages\r\n\r\nYou can install a deb package for Ubuntu 13.10 and 14.04 by adding this ppa:\r\n\r\n```\r\nsudo add-apt-repository ppa:juruen/cavalieri\r\nsudo apt-get update\r\nsudo apt-get install cavalieri\r\n```\r\n\r\n#### Debian\r\n\r\nPackges coming soon!\r\n\r\n#### Build from source\r\n\r\nHave a look at the build dependencies extracted from the deb package:\r\n\r\n\r\n```\r\ncmake, subversion, protobuf-compiler,libprotobuf-dev, libev-dev, libgflags-dev, \r\nlibgoogle-glog-dev, libpython-dev,libcurl4-openssl-dev, libssl-dev, libtbb-dev,\r\nlibjsoncpp-dev, lcov, flex, bison, libgoogle-glog-dev, libboost-filesystem-dev,\r\nlibboost-system-dev\r\n\r\n```\r\n\r\nYou will also need a C++11 enabled compiler. GCC >= 4.7 or an equivalent Clang.\r\n\r\nOnce the depencies are met. To build and install, do the following:\r\n\r\n```\r\nmkdir build\r\ncd build\r\ncmake ..\r\nmake install\r\n```\r\n\r\nCreate your rules\r\n-----------------\r\n\r\nClone *cavalieri-rules*, a template project to create your own rules.\r\n\r\n```sh\r\ngit clone https://github.com/juruen/cavalieri-rules.git\r\ncd cavalieri-rules\r\n```\r\n\r\nOpen *rules.cpp* and add your rules. The default rule will send an email\r\ncontaining a critical event when a metric from *requests_rate*\r\nservice is above 40.\r\n\r\n```cpp\r\n#include <rules.h>\r\n#include <external/pagerduty.h>\r\n#include <external/email.h>\r\n\r\nstreams_t rules() {\r\n\r\n  auto mail_stream = email(\"localhost\", \"cavalieri@localhost\",\r\n                           \"devops@localhost\");\r\n\r\n  auto s =  service(\"requests_rate\")\r\n               >> above(40)\r\n                 >> set_state(\"critical\")\r\n                   >> changed_state(\"ok\")\r\n                     >>  mail_stream;\r\n\r\n  return s;\r\n}\r\n\r\nEXPORT_RULES(rules)\r\n```\r\n\r\nBuild a plugin containing your rules that will be loaded by *cavalieri*.\r\n\r\n```sh\r\nmkdir build\r\ncd build\r\ncmake ..\r\nmake\r\n```\r\n\r\nThe above step generates a *librules.so* file that *cavalieri* will load.\r\n\r\nExecute cavalieri in the build directory or use the **-rules_directory**\r\nflag to specifify where the plugin is.\r\n\r\n```\r\n$ cavalieri\r\nI0403 23:15:44 config.cpp:36] config:\r\nI0403 23:15:44 config.cpp:37]      events_port: 5555\r\nI0403 23:15:44 config.cpp:38]      rimeann_tcp_pool_size:: 1\r\nI0403 23:15:44 config.cpp:39]      ws_port: 5556\r\nI0403 23:15:44 config.cpp:40]      ws_pool_size: 1\r\nI0403 23:15:44 config.cpp:41]      index_expire_interval: 60\r\nI0403 23:15:44 config.cpp:42]      rules_directory: .\r\nI0403 23:15:44 config.cpp:43] --\r\nI0403 23:15:44 rules_loader.cpp:60] rules loaded succesfully from librules.so\r\n\r\n```\r\n\r\nTest your rules\r\n---------------\r\n\r\nYou can easily test your rules without putting them in production.\r\n\r\nIn the root directory of *cavalieri-template* there is a Python script that will\r\nhelp you to find out whether your rules are doing what you expect or not.\r\n\r\nThe way it works is pretty simple. Open *test_rules.py* and add the events that \r\nare supposed to trigger your alerts.  By default, you already have some events\r\nthat will trigger an alert for the default rules:\r\n\r\n```python\r\nevents = [\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 10, 'time': 0},\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 20, 'time': 60},\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 40, 'time': 120},\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 45, 'time': 180},\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 45, 'time': 240},\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 20, 'time': 300},\r\n  {'host': 'foo.org', 'service': 'requests_rate', 'metric': 10, 'time': 360}]\r\n  ```\r\n\r\nLet's have a look at the default rules again:\r\n\r\n```cpp\r\n\r\n[...]\r\n\r\nauto s =  service(\"requests_rate\")\r\n           >> above(40)\r\n             >> set_state(\"critical\")\r\n               >> changed_state(\"ok\")\r\n                 >>  mail_stream;\r\n\r\n[...]\r\n\r\n```\r\n\r\nAs you can see, the events defined in *test_rules.py* will trigger an alert\r\nwhen the metric is above 40. This happens for the event that is sent\r\nat time *180*.\r\n\r\nYou can execute *test_rules.py* from the root directory of\r\n*cavalieri-template*. And you will magically see what happens to your\r\nrules when those events are passed through them:\r\n\r\n```json\r\n{\r\n   \"index\" : [],\r\n   \"reports\" : [\r\n      [\r\n         \"email\",\r\n         {\r\n            \"event\" : {\r\n               \"description\" : \"\",\r\n               \"host\" : \"foo.org\",\r\n               \"metric\" : 45.0,\r\n               \"service\" : \"requests_rate\",\r\n               \"state\" : \"critical\",\r\n               \"tags\" : [],\r\n               \"time\" : 180\r\n            },\r\n            \"extra\" : \"\",\r\n            \"message\" : \"send email from: cavalieri@localhost to: devops@localhost\",\r\n            \"time\" : 180\r\n         }\r\n      ]\r\n   ]\r\n}\r\n\r\n```\r\n\r\nAs you can see in the above output, *test_rules.py* is reporting that an email\r\nwould have been sent at time *180* to report that the *requests_rate* service\r\nis critical.\r\n\r\n*test_rules.py* makes use of *cavalieri_tester*, a binary that is capable of\r\nloading your rules and send events to them.\r\n\r\nHowever, it does so in an special environment,  where all the external calls\r\nsuch as email or pagerduty are mocked.  It also mocks the scheduler, that means\r\nyou can test months worth of events in just a few seconds.\r\n\r\nThis feature allows you to easily add your alert rules to your\r\ncontinous integration process.\r\n\r\n\r\nSending events\r\n--------------\r\n\r\nYou can use any of the existing [riemann.io](http://riemann.io/clients.html)\r\nclients. Just make them send events to a host running *cavalieri*.\r\n\r\nStreams API\r\n------------\r\n\r\n### Stream functions\r\n\r\n#### What is a stream function?\r\n\r\n#### prn()\r\n\r\nIt prints events that pass through it.\r\n\r\n#### prn (const std::string  str)\r\n\r\nIt prints events that pass through it and also the string that takes as an argument.\r\n\r\n#### service (const std::string service)\r\n\r\nIt forwards events that contain the given service.\r\n\r\n#### service_any (const std::vector&lt;std::string> services)\r\n\r\nIt forwards events that contain any of the given services. This\r\nbehaves just like *service* but it takes a list of services instead of\r\na single one.\r\n\r\n\r\n#### service_like (const std::string pattern)\r\n\r\nIt forards events which services match the given pattern.\r\n\r\n```cpp\r\nservice_like(\"foo%\") >> prn(\"service starting with foo\");\r\n```\r\n\r\n#### service_like_any (const std::vector&lt;std::string> patterns)\r\n\r\nIt forwards events which services match any of the given pattern. This\r\nbehaves just like *service_like* but it takes a list of patterns instead of\r\na single one.\r\n\r\n#### set_state (const std::string state)\r\n\r\nIt sets the events state to *state* and forwards them.\r\n\r\n\r\n#### set_metric (const double value);\r\n\r\nIt sets the events metric to *value* and forwards them.\r\n\r\n\r\n#### with (const with_changes_t & changes)\r\n\r\nModifies the event. It takes a map that contains the keys to be modified\r\nand their corresponding new value.\r\n\r\n```cpp\r\n// Change host field and description\r\nwith({{\"host\", \"cluster-001\"}, {\"description\", \"aggregated master metrics\"});\r\n```\r\n#### default_to (const with_changes_t & changes)\r\n\r\nIt takes a map that contains key-value pairs to be added to the event, but only\r\nin case the key is not set in the event already.\r\n\r\n\r\n```cpp\r\n// Default ttl to 120. Only events with the ttl field not set are modified.\r\ndefault_to({\"ttl\", 120});\r\n```\r\n\r\n#### split (const split_clauses_t clauses)\r\n\r\nIt takes a list of pairs. Each pair contains a predicate function and a stream.\r\nWhen an event is received, the event is passed to the first stream which\r\npredicate returns true.\r\n\r\n```cpp\r\nsplit({above_pred(10), set_state(\"ok\")},\r\n      {under_pred(5),  set_state(\"critical\"});\r\n```\r\n\r\n#### split (const split_clauses_t clauses, const streams_t default_stream)\r\n\r\nIt takes a list of pairs and a default stream. Each pair contains a predicate\r\nfunction and a stream.  When an event is received, the event is passed to the\r\nfirst stream which predicate returns true. If none of the predicates match,\r\nthe event is passed to the default stream.\r\n\r\n```cpp\r\nsplit({above_pred(10), set_state(\"ok\")},\r\n      {under_pred(5),  set_state(\"critical\")},\r\n      set_state(\"warning\"));\r\n```\r\n\r\n#### where (const predicate_t & predicate)\r\n\r\nIt passes events that make the predicate function return true.\r\n\r\n```cpp\r\nwhere(under_pred(5)) >> set_state(\"critical\") >> notiy_email();\r\n```\r\n\r\n#### where (const predicate_t & predicate, const streams_t else_stream)\r\n\r\nIt passes events that make the predicate function return true.\r\nOtherwise, events are passed to *else_stream*.\r\n\r\n```cpp\r\nabove_stream = set_state(\"ok\") >> prn(\"metric is above 5\");\r\n\r\nwhere(under_pred(5), above_stream) >> set_state(\"critical\") >> notiy_email(); \r\n```\r\n\r\n#### by (const by_keys_t  & keys, const streams_t stream)\r\n\r\nIt takes a list of event's fields. When an event enters this function,\r\nthe field(s) are retrieved, for every new value that has not been seen before,\r\nit will create a copy of *stream* and the event will be passed to it.\r\nIf the value was seen before, it will pass the event to the previously\r\ncreated stream.\r\n\r\nLet's see this in action. We are going to use a stream function called *rate*\r\nwhich simply sums the event metrics that receives during *dt* seconds and\r\ndivides the result by *dt*. Let's assume our servers send an event called\r\n*backend_exception* every time a request can't be handled and we would\r\nlike to see the exception rate per server.\r\n\r\nNote that if we just do what is below, we wouldn't get a per host rate,\r\nwe would get a global rate.\r\n\r\n```cpp\r\nauto rate_stream = set_metric(1) >> rate(60) >> prn(\"exceptions per second:\");\r\n```\r\n\r\nIf we want to compute the rate per host, that's when *by()* comes in handy.\r\nIt helps us  replicate the stream per each host so we can compute the rates\r\nindividually.\r\n\r\n```cpp\r\nauto rate_stream = set_metric(1)\r\n                      >> rate(60)\r\n                        >> prn(\"exceptions per second:\");\r\n\r\n// Use the host field and replicate rate_stream for evey distinct host.\r\nby({\"host\"}, rate_stream);\r\n```\r\n\r\nYou can pass several fields to *by()*.\r\n\r\n#### by (const by_keys_t  & keys)\r\n\r\nThis is similar to *by(const by keys_t & keys, const streams_t streams)*. But\r\ninstead of passing the streams to clone for every distinct combinations of\r\n*keys* as a parameter, it will duplicate the streams that are concatenated\r\nafter it.\r\n\r\nLet's see the example of the other *by()* function using this one.\r\n\r\n```cpp\r\n// Use the host field and replicate the stream that is next to it.\r\nby({\"host\"}) >> set_metric(1) >> rate(60) >> prn(\"exceptions per second:\");\r\n```\r\n\r\n\r\n#### rate (const uint32 & dt)\r\n\r\nIt sums the metrics of the received events for *dt* seconds. After that period,\r\nan event is forwarded and its metric contains the accumulated value divided\r\nby *dt*.\r\n\r\n\r\n```cpp\r\n// An easy way to count the rate of events that go through this stream\r\nwith({\"metric\", 1) >> rate(60) >> prn(\"events per second\");\r\n```\r\n\r\n#### coalesce (const fold_fn_t & fold_fn)\r\n\r\nIt keeps a map with the receivied events. Events are inserted in the map by\r\nusing the combination of ttheir host and service as a key.\r\n\r\nEvery time a new event is received, the map is updated and all the events in it\r\nare forwarded to the fold function.\r\n\r\nThis function is useful to aggregate metrics from different hosts.\r\n\r\n\r\n#### project (const predicates_t predicates, const fold_fn_t & fold_fn)\r\n\r\nSimilar to *coalesce* and more suitable when you just need a few events.\r\n\r\nIt takes a list of predicates.  For every predicate, the last event that\r\nmatches is stored. Whenever a new event arrives and matches\r\nany of the predicates, all the stored events are forwared to *fold_fn*.\r\n\r\n\r\n```cpp\r\n// Create a new event metric that is the sum of foo and bar\r\nproject({service_pred(\"foo\"), service_pred(\"bar\"), sum) >> prn(\"foo + bar\");\r\n```\r\n\r\n#### changed_state (const std::string & initial)\r\n\r\nIt only forwards events if there is a state change for every host and service.\r\nIt assummes *initial* as the first state.\r\n\r\nIf you are sending emails, this is useful to not spam yourself and only send\r\nemails when something goes from *ok* to *critical* and viceversa.\r\n\r\n#### tagged_any (const tags_t & tags)\r\n\r\nIt forwards events only if they contain any of the given *tags*.\r\n\r\n```cpp\r\ntagged_any({\"debian\", \"ubuntu\"}) >> above(5) >> email();\r\n```\r\n\r\n#### tagged_all (const tags_t & tags)\r\n\r\nIt forwards events only if they contain all the given *tags*.\r\n\r\n```cpp\r\ntagged_any({\"production\", \"london\"}) >> above(5) >> email();\r\n```\r\n\r\n#### tagged (const std::string tag)\r\n\r\nIt forwards events only if they contain the given *tag*.\r\n\r\n```cpp\r\ntagged(\"production\") >> above(5) >> email();\r\n```\r\n\r\n#### smap (const smap_fn_t fn)\r\n\r\nEvents are recevied and passed to *fn* which returns a new event.\r\nThis new event is forwarded.\r\n\r\nUse this when you need to modify events dynamically, as in opposed to\r\nstatically, use *with()* for the latter.\r\n\r\n```cpp\r\n// Function that takes and event and returns a new event which service\r\n// has the host appended.\r\nEvent host_service(e_t e)\r\n{\r\n  auto ne(e);\r\n  ne.set_service(e.service() + \"-\" + e.host());\r\n  return ne;\r\n};\r\n\r\nsmap(host_service) >> prn(\"new shiny service string\");\r\n```\r\n\r\n#### moving_event_window (const size_t n, const fold_fn_t fn)\r\n\r\nEvery time an event is received, the last *n* events are passed to *fn* which\r\nreturns a new event that is forwarded.\r\n\r\n\r\n#### fixed_event_window (const size_t n, const fold_fn_t fn)\r\n\r\nIt passes non-overlapping windows of *n* events to *fn* which returns\r\na new event that is forwarded.\r\n\r\n#### moving_event_window (const size_t dt, const fold_fn_t fn)\r\n\r\nEvery time an event is received, the last events within a *dt* window are\r\npassed to *fn* which returns a new event that is forwarded.\r\n\r\n#### fixed_time_window (const size_t dt, const fold_fn_t fn)\r\n\r\nIt passes non-overlapping windows of the events received within a *dt* window\r\nto *fn* which returns a new event that is forwarded.\r\n\r\n#### stable (const time_t dt)\r\n\r\nIt forwards events only when their state is the same for *dt* seconds.\r\nThis is useful to avoid spikes.\r\n\r\n#### throttle (size_t n, time_t dt)\r\n\r\nIt only forwards a maximum of *n* events during *dt* seconds.\r\n\r\n#### above (double k)\r\n\r\nIt forwards events with metrics above *k*.\r\n\r\n#### under (double k)\r\n\r\nIt forwards events with metrics under *k*.\r\n\r\n#### within (double a, double b)\r\n\r\nIt forwards events with metrics between *a* and *b*.\r\n\r\n#### without (double a, double b)\r\n\r\nIt forwards events with metrics not in the  (*a*, *b*) interval.\r\n\r\n#### scale (double s)\r\n\r\nIt scales events' metric by  *s* and forwards them.\r\n\r\n\r\n```cpp\r\n// Transform bytes in bits\r\nservice(\"eth0_incoming\") >> scale(8);\r\n```\r\n\r\n#### sdo ()\r\n\r\nIt just forwards events.\r\n\r\n#### counter ()\r\n\r\nIt counts the number of events that pass through it.\r\n\r\n#### expired ()\r\n\r\nIt forwards events that are expired.\r\n\r\n#### tags (tags_t tags)\r\n\r\nIt adds the list of passed *tags* to events and forwards them.\r\n\r\n```cpp\r\ntags({\"processed\"}) >> prn(\"tag added\")\r\n```\r\n\r\n#### ddt ()\r\n\r\nIt differenciates two subsequent events. The metric of the forwarded\r\nevent is (metric_current - metric_previous) / (time_current - time_previous).\r\n\r\n#### send_index()\r\n\r\nIt indexes the receivied events. Indexed events can be queried through\r\nthe websocket.\r\n\r\nThis is usful to know the current state of an event from a dashboard.\r\n\r\n#### send_graphite(const std::string host, const int port)\r\n\r\nIt forwards the received events to a graphite server using new line carbon\r\nTCP protocol.\r\n\r\nThis is an *external* function, meaning that cavalieri will talk to an external\r\nservice, in this case, a graphite server.\r\n\r\n#### forward(const std::string host, const int port)\r\n\r\nIt forwards the received events to a cavalieri or riemann server using\r\nTCP.\r\n\r\nThis is an *external* function, meaning that cavalieri will talk to an external\r\nservice, in this case, a cavalieri or riemann server.\r\n\r\n#### email(const std::string server, const std::string from, const std::string to)\r\n\r\nIt emails the received events with *from* sender to *to* recipient using\r\nthe specified SMTP *server*.\r\n\r\nThis is an *external* function, meaning that cavalieri will talk to an external\r\nservice, in this case, an SMTP server.\r\n\r\n\r\n\r\n#### pagerduty_trigger(const std::string pd_key)\r\n\r\nIt triggers a Pager Duty incident based on the received event and using\r\n*pd_key* as the API key. Note that service key will be event's host and\r\nservice.\r\n\r\nThis is an *external* function, meaning that cavalieri will talk to an external\r\nservice, in this case, Pager Duty.\r\n\r\n#### pagerduty_acknowoledge(const std::string pd_key)\r\n\r\nIt acknowledges a Pager Duty incident based on the received event and using\r\n*pd_key* as the API key. Note that service key will be event's host and\r\nservice.\r\n\r\nThis is an *external* function, meaning that cavalieri will talk to an external\r\nservice, in this case, Pager Duty.\r\n\r\n#### pagerduty_resolve(const std::string pd_key)\r\n\r\nIt resolves a Pager Duty incident based on the received event and using\r\n*pd_key* as the API key. Note that service key will be event's host and\r\nservice.\r\n\r\nThis is an *external* function, meaning that cavalieri will talk to an external\r\nservice, in this case, Pager Duty.\r\n\r\n\r\n### Fold functions\r\n\r\nFold functions are functions that take a list of events, do some processing\r\nwith them such as reducing and return an event with the result.\r\n\r\nThese functions are mostly meant to be used with stream functions that forward\r\na list of events.\r\n\r\n#### sum(const std::vector<Event> events)\r\n\r\nIt returns an event that contains the sum of the metrics of *events*.\r\n\r\n#### product(const std::vector<Event> events)\r\n\r\nIt returns an event that contains the product of the metrics of *events*.\r\n\r\n#### difference(const std::vector<Event> events)\r\n\r\nIt returns an event that contains the difference of the metrics of *events*.\r\n\r\n#### mean(const std::vector<Event> events)\r\n\r\nIt returns an event that contains the mean of the metrics of *events*.\r\n\r\n#### minimum(const std::vector<Event> events)\r\n\r\nIt returns an event that contains the minimum value of the metrics of *events*.\r\n\r\n#### maximum(const std::vector<Event> events)\r\n\r\nIt returns an event that contains the maximum of the metrics of *events*.\r\n\r\n### Common Rules\r\n\r\nThese rules are based on the above stream functions, but they are more\r\nhigh-level and more opinionated.\r\n\r\nThey asumme that two states *critical* and *ok* are enough. Events coming\r\nout from these function have their state set to any of them.\r\n\r\n#### critical_above (double value)\r\n\r\nIt sets state to critical if metric is above *value*. Otherwise, it sets it to\r\nok.\r\n\r\n#### critical_under (double value)\r\n\r\nIt sets state to ok if metric is under *value*. Otherwise, it sets it to\r\ncritical.\r\n\r\n#### stable_metric (double dt, predicate_t trigger)\r\n\r\nIt takes *trigger* as a function predicate to check events. It sets the state\r\nto critical when *trigger* has returned *true* for more than *dt* seconds.\r\n\r\nIt sets it back to critical when *trigger* has returned *false* for more than\r\n*dt* seconds.\r\n\r\nThis is useful to avoid spikes.\r\n\r\n```cpp\r\nstable_metric( /* seconds */ 300, above_pred(200))\r\n  >> changed_state(\"ok\")\r\n    >>  email();\r\n```\r\n\r\n#### stable_metric (double dt, predicate_t trigger, predicate_t cancel)\r\n\r\nSimilar to the above function but taking an extra predicate *cancel* that is\r\nused as a threshold to set it back to ok.\r\n\r\n\r\nIt sets the state to critical when *trigger* has return *true* for more than\r\n*dt* seconds.\r\n\r\nIt sets it back to critical when *cancel* has returned *true* for more than\r\n*dt* seconds.\r\n\r\nThis is useful to avoid spikes.\r\n\r\n```cpp\r\nstable_metric( /* seconds */ 300, above_pred(200))\r\n  >> changed_state(\"ok\")\r\n    >>  email();\r\n```\r\n\r\n\r\n#### agg_stable_metric (double dt, fold_fn_t fold_fn, predicate_t trigger, predicate_t cancel)\r\n\r\nThis function aggregates metrics of events that are received using\r\n*fold_fn* (See fold functions). The event that results is passed to a\r\n*stable_metric* stream using *dt*, *trigger* and *cancel*.\r\n\r\nLet's see an example. Say we have a bunch of web servers in our London data\r\ncenter. Those servers are reporting a metric called *failed_requests_rate*. We\r\nwould like to create another metric that is the aggregated sum of all the\r\nservers and trigger an alert when that value is above a given value for\r\nmore than *dt* seconds.\r\n\r\n```cpp\r\nservice(\"failed_requests_rate\")\r\n  >> tagged(\"datacenter::london\")\r\n    >> agg_stable_metric(/* secs */ 300, sum, above_pred(200), under_pred(50))\r\n      >> changed_state(\"ok\")\r\n        >> email();\r\n```\r\n\r\n\r\n#### max_critical_hosts(size_t n)\r\n\r\nThis function sets the state of the events to critical when it receives\r\nmore than *n* different critical events.\r\n\r\nIn the example below, we trigger an alert when more than 20 servers\r\nreport a puppet failure in a DC.\r\n\r\n```cpp\r\nservice(\"puppet\")\r\n  >> tagged(\"datacenter::paris\")\r\n    >> max_critial_hosts(20)\r\n      >> changed_state(\"ok\")\r\n        >> set_host(\"datacenter::paris\")\r\n          >> set_service(\"too many puppet failures\")\r\n            >> email();\r\n```\r\n\r\n\r\n### Predicate functions\r\n\r\n### Some utility functions\r\n\r\n### Some typedefs\r\n\r\nDashboard\r\n---------\r\n\r\nYou can use the standard [riemann.io dahsboard](http://riemann.io/dashboard.html)\r\nto query and visualize the state of the index.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}