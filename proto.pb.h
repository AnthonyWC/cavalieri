// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto.proto

#ifndef PROTOBUF_proto_2eproto__INCLUDED
#define PROTOBUF_proto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2eproto();
void protobuf_AssignDesc_proto_2eproto();
void protobuf_ShutdownFile_proto_2eproto();

class State;
class Event;
class Query;
class Msg;
class Attribute;

// ===================================================================

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();
  
  State(const State& from);
  
  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();
  
  void Swap(State* other);
  
  // implements Message ----------------------------------------------
  
  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional string state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  
  // optional string service = 3;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 3;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  
  // optional string host = 4;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 4;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  
  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional bool once = 6;
  inline bool has_once() const;
  inline void clear_once();
  static const int kOnceFieldNumber = 6;
  inline bool once() const;
  inline void set_once(bool value);
  
  // repeated string tags = 7;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 7;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();
  
  // optional float ttl = 8;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 8;
  inline float ttl() const;
  inline void set_ttl(float value);
  
  // @@protoc_insertion_point(class_scope:State)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_once();
  inline void clear_has_once();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 time_;
  ::std::string* state_;
  ::std::string* service_;
  ::std::string* host_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  bool once_;
  float ttl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2eproto();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();
  
  void InitAsDefaultInstance();
  static State* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional string state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  
  // optional string service = 3;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 3;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  
  // optional string host = 4;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 4;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  
  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // repeated string tags = 7;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 7;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();
  
  // optional float ttl = 8;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 8;
  inline float ttl() const;
  inline void set_ttl(float value);
  
  // repeated .Attribute attributes = 9;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 9;
  inline const ::Attribute& attributes(int index) const;
  inline ::Attribute* mutable_attributes(int index);
  inline ::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Attribute >*
      mutable_attributes();
  
  // optional sint64 metric_sint64 = 13;
  inline bool has_metric_sint64() const;
  inline void clear_metric_sint64();
  static const int kMetricSint64FieldNumber = 13;
  inline ::google::protobuf::int64 metric_sint64() const;
  inline void set_metric_sint64(::google::protobuf::int64 value);
  
  // optional double metric_d = 14;
  inline bool has_metric_d() const;
  inline void clear_metric_d();
  static const int kMetricDFieldNumber = 14;
  inline double metric_d() const;
  inline void set_metric_d(double value);
  
  // optional float metric_f = 15;
  inline bool has_metric_f() const;
  inline void clear_metric_f();
  static const int kMetricFFieldNumber = 15;
  inline float metric_f() const;
  inline void set_metric_f(float value);
  
  // @@protoc_insertion_point(class_scope:Event)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_metric_sint64();
  inline void clear_has_metric_sint64();
  inline void set_has_metric_d();
  inline void clear_has_metric_d();
  inline void set_has_metric_f();
  inline void clear_has_metric_f();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 time_;
  ::std::string* state_;
  ::std::string* service_;
  ::std::string* host_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::Attribute > attributes_;
  ::google::protobuf::int64 metric_sint64_;
  float ttl_;
  float metric_f_;
  double metric_d_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2eproto();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message {
 public:
  Query();
  virtual ~Query();
  
  Query(const Query& from);
  
  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();
  
  void Swap(Query* other);
  
  // implements Message ----------------------------------------------
  
  Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string string = 1;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 1;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  
  // @@protoc_insertion_point(class_scope:Query)
 private:
  inline void set_has_string();
  inline void clear_has_string();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* string_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2eproto();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();
  
  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// -------------------------------------------------------------------

class Msg : public ::google::protobuf::Message {
 public:
  Msg();
  virtual ~Msg();
  
  Msg(const Msg& from);
  
  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg& default_instance();
  
  void Swap(Msg* other);
  
  // implements Message ----------------------------------------------
  
  Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg& from);
  void MergeFrom(const Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool ok = 2;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 2;
  inline bool ok() const;
  inline void set_ok(bool value);
  
  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // repeated .State states = 4;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 4;
  inline const ::State& states(int index) const;
  inline ::State* mutable_states(int index);
  inline ::State* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::State >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::State >*
      mutable_states();
  
  // optional .Query query = 5;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 5;
  inline const ::Query& query() const;
  inline ::Query* mutable_query();
  inline ::Query* release_query();
  
  // repeated .Event events = 6;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 6;
  inline const ::Event& events(int index) const;
  inline ::Event* mutable_events(int index);
  inline ::Event* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Event >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Event >*
      mutable_events();
  
  // @@protoc_insertion_point(class_scope:Msg)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_query();
  inline void clear_has_query();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* error_;
  ::google::protobuf::RepeatedPtrField< ::State > states_;
  ::Query* query_;
  ::google::protobuf::RepeatedPtrField< ::Event > events_;
  bool ok_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2eproto();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();
  
  void InitAsDefaultInstance();
  static Msg* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message {
 public:
  Attribute();
  virtual ~Attribute();
  
  Attribute(const Attribute& from);
  
  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();
  
  void Swap(Attribute* other);
  
  // implements Message ----------------------------------------------
  
  Attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:Attribute)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2eproto();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();
  
  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// ===================================================================


// ===================================================================

// State

// optional int64 time = 1;
inline bool State::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 State::time() const {
  return time_;
}
inline void State::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string state = 2;
inline bool State::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& State::state() const {
  return *state_;
}
inline void State::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void State::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void State::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* State::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string service = 3;
inline bool State::has_service() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_service() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_service() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_service() {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& State::service() const {
  return *service_;
}
inline void State::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void State::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void State::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  return service_;
}
inline ::std::string* State::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string host = 4;
inline bool State::has_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& State::host() const {
  return *host_;
}
inline void State::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void State::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void State::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* State::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 5;
inline bool State::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void State::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& State::description() const {
  return *description_;
}
inline void State::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void State::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void State::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* State::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool once = 6;
inline bool State::has_once() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void State::set_has_once() {
  _has_bits_[0] |= 0x00000020u;
}
inline void State::clear_has_once() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void State::clear_once() {
  once_ = false;
  clear_has_once();
}
inline bool State::once() const {
  return once_;
}
inline void State::set_once(bool value) {
  set_has_once();
  once_ = value;
}

// repeated string tags = 7;
inline int State::tags_size() const {
  return tags_.size();
}
inline void State::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& State::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* State::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void State::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void State::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void State::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::add_tags() {
  return tags_.Add();
}
inline void State::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void State::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void State::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
State::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
State::mutable_tags() {
  return &tags_;
}

// optional float ttl = 8;
inline bool State::has_ttl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void State::set_has_ttl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void State::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void State::clear_ttl() {
  ttl_ = 0;
  clear_has_ttl();
}
inline float State::ttl() const {
  return ttl_;
}
inline void State::set_ttl(float value) {
  set_has_ttl();
  ttl_ = value;
}

// -------------------------------------------------------------------

// Event

// optional int64 time = 1;
inline bool Event::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Event::time() const {
  return time_;
}
inline void Event::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string state = 2;
inline bool Event::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Event::state() const {
  return *state_;
}
inline void Event::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Event::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Event::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* Event::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string service = 3;
inline bool Event::has_service() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_service() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_service() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_service() {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& Event::service() const {
  return *service_;
}
inline void Event::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void Event::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void Event::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  return service_;
}
inline ::std::string* Event::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string host = 4;
inline bool Event::has_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& Event::host() const {
  return *host_;
}
inline void Event::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void Event::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void Event::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* Event::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 5;
inline bool Event::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Event::description() const {
  return *description_;
}
inline void Event::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Event::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Event::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Event::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string tags = 7;
inline int Event::tags_size() const {
  return tags_.size();
}
inline void Event::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Event::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* Event::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void Event::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void Event::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void Event::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::add_tags() {
  return tags_.Add();
}
inline void Event::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void Event::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void Event::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Event::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Event::mutable_tags() {
  return &tags_;
}

// optional float ttl = 8;
inline bool Event::has_ttl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_ttl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_ttl() {
  ttl_ = 0;
  clear_has_ttl();
}
inline float Event::ttl() const {
  return ttl_;
}
inline void Event::set_ttl(float value) {
  set_has_ttl();
  ttl_ = value;
}

// repeated .Attribute attributes = 9;
inline int Event::attributes_size() const {
  return attributes_.size();
}
inline void Event::clear_attributes() {
  attributes_.Clear();
}
inline const ::Attribute& Event::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::Attribute* Event::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::Attribute* Event::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Attribute >&
Event::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Attribute >*
Event::mutable_attributes() {
  return &attributes_;
}

// optional sint64 metric_sint64 = 13;
inline bool Event::has_metric_sint64() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_metric_sint64() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_metric_sint64() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_metric_sint64() {
  metric_sint64_ = GOOGLE_LONGLONG(0);
  clear_has_metric_sint64();
}
inline ::google::protobuf::int64 Event::metric_sint64() const {
  return metric_sint64_;
}
inline void Event::set_metric_sint64(::google::protobuf::int64 value) {
  set_has_metric_sint64();
  metric_sint64_ = value;
}

// optional double metric_d = 14;
inline bool Event::has_metric_d() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Event::set_has_metric_d() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Event::clear_has_metric_d() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Event::clear_metric_d() {
  metric_d_ = 0;
  clear_has_metric_d();
}
inline double Event::metric_d() const {
  return metric_d_;
}
inline void Event::set_metric_d(double value) {
  set_has_metric_d();
  metric_d_ = value;
}

// optional float metric_f = 15;
inline bool Event::has_metric_f() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Event::set_has_metric_f() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Event::clear_has_metric_f() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Event::clear_metric_f() {
  metric_f_ = 0;
  clear_has_metric_f();
}
inline float Event::metric_f() const {
  return metric_f_;
}
inline void Event::set_metric_f(float value) {
  set_has_metric_f();
  metric_f_ = value;
}

// -------------------------------------------------------------------

// Query

// optional string string = 1;
inline bool Query::has_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query::set_has_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query::clear_has_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& Query::string() const {
  return *string_;
}
inline void Query::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void Query::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void Query::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* Query::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Msg

// optional bool ok = 2;
inline bool Msg::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool Msg::ok() const {
  return ok_;
}
inline void Msg::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
}

// optional string error = 3;
inline bool Msg::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& Msg::error() const {
  return *error_;
}
inline void Msg::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Msg::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Msg::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* Msg::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .State states = 4;
inline int Msg::states_size() const {
  return states_.size();
}
inline void Msg::clear_states() {
  states_.Clear();
}
inline const ::State& Msg::states(int index) const {
  return states_.Get(index);
}
inline ::State* Msg::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::State* Msg::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::State >&
Msg::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::State >*
Msg::mutable_states() {
  return &states_;
}

// optional .Query query = 5;
inline bool Msg::has_query() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg::set_has_query() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg::clear_has_query() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg::clear_query() {
  if (query_ != NULL) query_->::Query::Clear();
  clear_has_query();
}
inline const ::Query& Msg::query() const {
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::Query* Msg::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::Query;
  return query_;
}
inline ::Query* Msg::release_query() {
  clear_has_query();
  ::Query* temp = query_;
  query_ = NULL;
  return temp;
}

// repeated .Event events = 6;
inline int Msg::events_size() const {
  return events_.size();
}
inline void Msg::clear_events() {
  events_.Clear();
}
inline const ::Event& Msg::events(int index) const {
  return events_.Get(index);
}
inline ::Event* Msg::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::Event* Msg::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Event >&
Msg::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Event >*
Msg::mutable_events() {
  return &events_;
}

// -------------------------------------------------------------------

// Attribute

// required string key = 1;
inline bool Attribute::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Attribute::key() const {
  return *key_;
}
inline void Attribute::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Attribute::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Attribute::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Attribute::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 2;
inline bool Attribute::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Attribute::value() const {
  return *value_;
}
inline void Attribute::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Attribute::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Attribute::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Attribute::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2eproto__INCLUDED
